<font face=STKaiti><center>

# 中山大学计算机学院本科生实验报告
### （2025学年第1学期）</center>


课程名称：数据结构与算法实验 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任课老师：张子臻
|  |  |  |  |
|:-----:|:-------:|:-------:|:--------:|
| 年级: | 2024级   | 专业(方向):   | 计算机科学与技术(人工智能与大数据)
| 学号: | 24325155 | 姓名: | 梁桂铭
| 电话: | 15817681625 | Email: | lianggm8@mail2.sysu.edu.cn
| 开始日期: | 2025年10月11日 | 完成日期: | 2025年10月11日

---

## 第三题

### 1.实验题目

#### 题目描述

实现二分查找函数，函数接口如下：

```cpp
#include "binSearch.h"
int binSearch(const int s[], const int size, const int target)
{
    // 请将实现代码添加在这里
}
```

`size`为数组`s`的实际大小。假定`s`为**非递减有序**，若`s`中存在值为`target`的元素，返回**最后一次出现**的下标；否则返回`-1`。下标从0开始。

调用样例：
```cpp
int s[8] = {0,1,1,3,3,3,6,6};
cout << binSearch(s,8,3) << endl; // 输出 5
cout << binSearch(s,8,4) << endl; // 输出 -1
```

---

### 2.实验目的

1. 理解并掌握**二分查找（Binary Search）**的基本思想与实现。
2. 学会处理**重复元素**时的“最后出现位置”搜索。
3. 熟悉在**有序数组**中利用中点缩小查找范围的技巧。

---

### 3.算法设计

#### (1) 思路分析

普通二分查找在找到目标值后通常直接返回下标，但本题要求返回**最后一次出现的位置**。  
因此需要在找到目标后**继续向右搜索**，直到不再满足条件为止。

#### (2) 算法步骤

1. 初始化左右边界：`l = 0, r = size - 1`；
2. 取中点 `mid = (l + r) / 2`；
3. 若 `s[mid] <= target`，说明目标可能在右半区，为了找到“最后一次”，让 `l = mid + 1`；
4. 否则 `r = mid - 1`；
5. 循环结束后，若 `s[r] == target`，则返回 `r`，否则返回 `-1`。

这种方式在每次匹配时继续右移，可以确保最终返回最后出现的下标。

#### (3) 代码实现

```cpp
#include "binSearch.h"

int binSearch(const int s[], const int size, const int target) {
    int l = 0, r = size - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (s[mid] <= target)
            l = mid + 1;
        else
            r = mid - 1;
    }
    if (r >= 0 && s[r] == target) return r;
    return -1;
}
```

#### (4) 复杂度分析

- **时间复杂度**：`O(log n)`  
  每次循环将查找区间减半。
- **空间复杂度**：`O(1)`  
  仅使用常数级变量。

---

### 4.程序运行与测试

#### 测试样例

| 输入数组 | target | 输出 | 说明 |
|:-----------:|:-----------:|:-----------:|:-----------:|
| `{0,1,1,3,3,3,6,6}` | `3` | `5` | 最后一次出现位置 |
| `{0,1,1,3,3,3,6,6}` | `4` | `-1` | 不存在 |
| `{1,2,2,2,3}` | `2` | `3` | 连续重复测试 |
| `{5}` | `5` | `0` | 单元素数组 |

#### 运行结果

输出结果如下：

```
5
-1
3
0
```

均符合预期。

---

### 5.实验总结与心得

本实验巩固了**二分查找**的原理与变形应用。  
相比普通查找，本题要求“最后一次出现”，因此在比较时需调整区间移动方向。  
在实现过程中要注意：
- 取中点时避免溢出，使用 `l + (r - l)/2`；
- 结束条件应为 `l <= r`，否则可能遗漏边界元素。  

通过本实验，我进一步掌握了**边界控制与逻辑判断**在算法设计中的重要性，也体会到二分查找不仅能用于查值，还可灵活扩展到“最左”“最右”等变体。

---

## 附录、提交文件清单

### 第三题
```cpp
#include "binSearch.h"

int binSearch(const int s[], const int size, const int target) {
    int l = 0, r = size - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (s[mid] <= target)
            l = mid + 1;
        else
            r = mid - 1;
    }
    if (r >= 0 && s[r] == target) return r;
    return -1;
}
```
</font>
